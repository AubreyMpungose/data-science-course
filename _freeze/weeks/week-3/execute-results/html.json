{
  "hash": "9bb6447271450cb7e5b34048080341b8",
  "result": {
    "markdown": "---\ntitle: \"3 Data Manipulation\"\ncode-copy: true\ncode-line-numbers: true\ntidy: true\ntoc: true\n---\n\n\n# 3.1 PART I\n\n## Learning objectives\n\n-   Understand dataframes\n\n-   Manipulate, transform and analyse dataframes\n\n## 3.1.1 Introduction\n\nDataframes, as we saw [the previous section](/weeks/week-2.html), a dataframe is a tabular data format, with columns and rows. Columns are *variable* names and rows are individual *observations*. Let us recreate the previous dataframe of names and ages of this class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Firstly, create a character vector with names\nnames <- c(\"thabiso\", \"nontando\", \"thandolwethu\", \"akhona\", \"perry\", \"balindile\", \"thembelani\", \"sabeliwe\",  \"phakamani\",    \"obianuju\", \"tshepang\", \"charity\", \"lungelo\", \"ntsikelelo\", \"akhona\", \"duduzile\")\n\nset.seed(14) #I do this so that we can get same results every time we generate numbers or simulate\n\n# Create a numeric vector of ages\nage <- sample(18:32, 16, replace = T)\n\n# Create a dataframe\ndata_frame <- data.frame(names, age) \n\n# print the dataframe\ndata_frame \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          names age\n1       thabiso  26\n2      nontando  26\n3  thandolwethu  28\n4        akhona  21\n5         perry  28\n6     balindile  31\n7    thembelani  31\n8      sabeliwe  21\n9     phakamani  27\n10     obianuju  32\n11     tshepang  18\n12      charity  26\n13      lungelo  20\n14   ntsikelelo  29\n15       akhona  22\n16     duduzile  20\n```\n:::\n:::\n\n\nA dataframe is basically made of vectors. In our data_frame, we have character (names) and numeric (age) vectors that make our dataframe. We can extract these elements using the `$` sign:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_frame$names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"thabiso\"      \"nontando\"     \"thandolwethu\" \"akhona\"       \"perry\"       \n [6] \"balindile\"    \"thembelani\"   \"sabeliwe\"     \"phakamani\"    \"obianuju\"    \n[11] \"tshepang\"     \"charity\"      \"lungelo\"      \"ntsikelelo\"   \"akhona\"      \n[16] \"duduzile\"    \n```\n:::\n\n```{.r .cell-code}\ndata_frame$age\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 26 26 28 21 28 31 31 21 27 32 18 26 20 29 22 20\n```\n:::\n:::\n\n\nWe can do a range of analysis with a dataframe. But firstly, we need to use right functions for this task.\n\n## 3.1.2 Base R vs Tidyverse\n\nUntil now, we have used functions within **Base R**, which are already installed in R. But in many cases, we want to use external packages to do any task we want. For example, if we want to do spatial and GIS analysis, we can install the `sf` package; we can use `tidymodels` to conduct machine learning models and so on. There are over 2000 R packages, contributed by different individuals around the world, and they are stored and curated in the [CRAN website](https://cran.r-project.org/web/packages/).\n\nOne of the most popular packages in R is the `tidyverse` meta-package, which include a collection of packages for working with data; most popular packages in the `tidyverse` are:\n\n-   `dplyr`: for data cleaning, wrangling and transformation\n\n-   `ggplot2`: for data visualisation\n\n-   `tidyr`: for tidying up data\n\nThere are other packages in the `tidyverse`. The philosophy of `tidyverse` is *tidy* data:\n\n> 1.  Each variable is a column; each column is a variable.\n> 2.  Each observation is row; each row is an observation.\n> 3.  Each value is a cell; each cell is a single value. [@r_4_ds]\n\nTidy data is a principle we are going to stick on through this course:\n\n![Tidy data @wickham_tidyverse_2019](images/tidy_data.png)\n\nSo all in all, tidyverse make it easier to work with dataframes and most people prefer it than base R functions. We will use an example at the end to understand the differences between Base R and tydiverse. You will need to install the package first. In R you install a package by calling `install.package()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nAfter installing the package, you need to load it into the current R session using `library()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n## 3.1.3 Using `dplyr`\n\nIn this section `dplyr` packages, which is included in the `tidyverse` collection of packages. `dplyr` has 5 verbs/functions:\n\n-   `select()`\n\n-   `filter()`\n\n-   `arrange()`\n\n-   `summarise()`\n\n-   `mutate()`\n\n### Load the dataset\n\nAll along, we have been working with fictional data. Let us use the `gapminder` dataset, which can be installed as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"gapminder\")\n```\n:::\n\n\nAfter installing the `gapminder` data, you will have to load it using `library` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\n```\n:::\n\n\nThan assign it to the object, `gapminder`, using the `<-` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- gapminder\n```\n:::\n\n\nNow you have an object, which is a dataframe, called `gapminder`, you can see it in the `Environment` pane in RStudio. It shows that it has `ncol(gapminder)` columns/variables and `nrow(gapminder)` observations/rows\n\n![`gapminder` dataframe in Environment pane](images/environment_pane.png)\n\nYou can use the `str()` fucntion to get the structure of the dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n```\n:::\n:::\n\n\nWe have 6 variables:\n- \"country\" \n\n- \"continent\" \n\n- \"year\"      \n\n- \"lifeExp\": life expectancy of a country  \n\n- \"pop\": population     \n\n- \"gdpPercap\": GDP per capita\n\nYou can get a sample of the first observations/rows using `head()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n```\n:::\n:::\n\n\n### 3.1.4 `select()` function\n\nWe may be interested in some of the columns in the `gampminder` dataframe, let say, for example, \"country\" and \"pop\" variables and discard others; we use the `select()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nselect(gapminder, \"country\", \"pop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nR return only the country and population variables. `select()` function only return the variables/columns we are interested in:\n\n![](images/visualise_select.png)\n\n\nThe best way to work with R is using a pipe (`|>`) operator. A pipe operator connect various tasks, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  select(country, pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nYou will see the importance of the pipe operator later when our analysis get complicated. Throught the course, we will use the pipe operator. Also, you will in many textbooks and online resources uses the `%>%` operator instead. That is because initially, a pipe operator was an external function within the `mgttr` package, so it was not an built-in R function. In recent years, the base R `|>` pipe operator has been developed and we will stick to it. But they all do the same thing, so it your preference:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  select(country, pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nAlso, notice that we selected \"country' and \"pop\" columns but did not save them and assigned to an object. To store the results into an object, we have to use assignment operator (`<-`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_selected <- gapminder |>\n  select(country, pop)\n\ngapminder_selected # print\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nNow we have saved results as `gapminder_selected`, and we can do other analysis with this object because we have saved it. So, in a nutshell, when you run a code without assigning results into an object, using the `<-` operator, **results will not be saved but will be printed**.\n\n### 3.1.5 `filter()` function\n\nYou may be interested in observations that meet certain conditions. We use `filter()` function to return the list that meet our conditions. Let us \"continent\" variable in `gapminder` dataframe. Get a basic table first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(gapminder$continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n```\n:::\n:::\n\n\nFilter has several operators:\n\n- `==`: equal to\n\n- `!=`: not equal to\n\n- `>`: greater than\n\n- `<`: less than\n\n- `>=`: greater than or equal to\n\n- `<=`: less than or equal to\n\nThere are five continents. Let us filter only observations from the Africa continent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nafrica_gapminder <- gapminder |> \n  filter(continent == \"Africa\")\n\nafrica_gapminder  # print \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 624 × 6\n   country continent  year lifeExp      pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# … with 614 more rows\n```\n:::\n:::\n\n\n\n`africa_gapminder` object is a dataframe we have just created, with only countries from the African continent. What `filter()` does is to return observations/rows that only meet our conditions:\n\n![](images/visualise_filter.png)\n\nLet us filter a numeric vector; for example, we may want to filter countries with population of above 50 million and assign results to an object named high_pop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhigh_pop <- gapminder |> \n  filter(pop > 50000000)\n\nhigh_pop\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 190 × 6\n   country    continent  year lifeExp       pop gdpPercap\n   <fct>      <fct>     <int>   <dbl>     <int>     <dbl>\n 1 Bangladesh Asia       1957    39.3  51365468      662.\n 2 Bangladesh Asia       1962    41.2  56839289      686.\n 3 Bangladesh Asia       1967    43.5  62821884      721.\n 4 Bangladesh Asia       1972    45.3  70759295      630.\n 5 Bangladesh Asia       1977    46.9  80428306      660.\n 6 Bangladesh Asia       1982    50.0  93074406      677.\n 7 Bangladesh Asia       1987    52.8 103764241      752.\n 8 Bangladesh Asia       1992    56.0 113704579      838.\n 9 Bangladesh Asia       1997    59.4 123315288      973.\n10 Bangladesh Asia       2002    62.0 135656790     1136.\n# … with 180 more rows\n```\n:::\n:::\n\n\nYou can also combine 2 conditions. Let us say we want:\n\n- countries in Africa\n\n- year 2007\n\n- that have a population of more than 50 million\n\nWe can combine these arguments and assign results into an object we name `africa_2007`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nafrica_2007 <- gapminder |> \n  filter(continent == \"Africa\", year == 2007, pop > 50000000)\n\n# print the result\nafrica_2007\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n1 Congo, Dem. Rep. Africa     2007    46.5  64606759      278.\n2 Egypt            Africa     2007    71.3  80264543     5581.\n3 Ethiopia         Africa     2007    52.9  76511887      691.\n4 Nigeria          Africa     2007    46.9 135031164     2014.\n```\n:::\n:::\n\n\nYou may want to filter out or remove rows, let us say, only `Europe` in the `continent`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(continent != \"Europe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,344 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,334 more rows\n```\n:::\n:::\n\n\nOne of the common mistakes when using filter are:\n\n- using `=` instead of `==`\n\n- using `>`, `<` to character vectors\n\n\n### 3.1.6 `arrange()` function\n\n`arrange()` function sort values in ascending or descending order; the default is ascending:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  arrange(lifeExp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nHere we have sorted `lifeExp` column in ascending order; to arrange in descending order, you have to use `desc()` function within `arrange()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  arrange(desc(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 6\n   country          continent  year lifeExp       pop gdpPercap\n   <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n 1 Japan            Asia       2007    82.6 127467972    31656.\n 2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n 3 Japan            Asia       2002    82   127065841    28605.\n 4 Iceland          Europe     2007    81.8    301931    36181.\n 5 Switzerland      Europe     2007    81.7   7554661    37506.\n 6 Hong Kong, China Asia       2002    81.5   6762476    30209.\n 7 Australia        Oceania    2007    81.2  20434176    34435.\n 8 Spain            Europe     2007    80.9  40448191    28821.\n 9 Sweden           Europe     2007    80.9   9031088    33860.\n10 Israel           Asia       2007    80.7   6426679    25523.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\n### 3.1.7 `summarise()`\n\nThe `summarise()` function is for calculating statistics such as mean, median, sum, min, max, etc. let us use examples. We may want the average GDP per capita in in 2007:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first filter the year 2007 and save the results as gapminder_2007\n\ngapminder_2007 <- gapminder |> \n  filter(year == 2007)\n\n# then use use the summarise() function\n\ngapminder_2007 |> \n  summarise(avg_gdp = mean(gdpPercap))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  avg_gdp\n    <dbl>\n1  11680.\n```\n:::\n:::\n\n  \nNotice that we have called `summarise()` from the `dplyr` package, then created a column `avg_gdp` that use the built-in (base R) `mean()` function and put the `gdpPercap` column within it to get the average GDP per capita in 2007:\n\n![](images/visualise_summarise.png)\n\n\nThis is similar for other stats: median:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 |> \n  summarise(median_life_exp = median(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  median_life_exp\n            <dbl>\n1            71.9\n```\n:::\n:::\n\n\nWe can get minimum (using `min()`), maximum (`max()`), sum (`sum()`) etc. get the lowest population:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 |> \n  summarise(lowest_pop = min(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  lowest_pop\n       <int>\n1     199579\n```\n:::\n:::\n\n\nGet the highest population:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 |> \n  summarise(highest_pop = max(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  highest_pop\n        <int>\n1  1318683096\n```\n:::\n:::\n\n\n\nGet the total world population:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 |> \n  summarise(total_pop = sum(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n   total_pop\n       <dbl>\n1 6251013179\n```\n:::\n:::\n\n\n### 3.1.8 `mutate()`\n\nSuppose we want to create a new column in the dataframe, using existing columns. The `mutate()` function is useful here. Consider the `gdpPercap` column/variable; from your basic school economics or general knowledge, you know that a GDP is total value of goods and services produced within a country, and is used to measure the economy. We also know that the GDP per capita is calculated by dividing GDP by the population, so it is GDP per person. In `gapminder` dataframe, there are `gdpPercap` and `pop`, which we can use to calculate GDP of a country; we will use `mutate()` for this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 <- gapminder_2007 |> \n  mutate(gdp = gdpPercap * pop)\n\n# print the results\n\ngapminder_2007\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 142 × 7\n   country     continent  year lifeExp       pop gdpPercap           gdp\n   <fct>       <fct>     <int>   <dbl>     <int>     <dbl>         <dbl>\n 1 Afghanistan Asia       2007    43.8  31889923      975.  31079291949.\n 2 Albania     Europe     2007    76.4   3600523     5937.  21376411360.\n 3 Algeria     Africa     2007    72.3  33333216     6223. 207444851958.\n 4 Angola      Africa     2007    42.7  12420476     4797.  59583895818.\n 5 Argentina   Americas   2007    75.3  40301927    12779. 515033625357.\n 6 Australia   Oceania    2007    81.2  20434176    34435. 703658358894.\n 7 Austria     Europe     2007    79.8   8199783    36126. 296229400691.\n 8 Bahrain     Asia       2007    75.6    708573    29796.  21112675360.\n 9 Bangladesh  Asia       2007    64.1 150448339     1391. 209311822134.\n10 Belgium     Europe     2007    79.4  10392226    33693. 350141166520.\n# … with 132 more rows\n```\n:::\n:::\n\n\n`mutate()` has added a new column named `gdp`:\n\n![](images/visualise_mutate.png)\n\n# 3.2 PART II: Other `dplyr` verbs\n\nThere are other important `dplyr` functions that are useful for data manipulation. We still use the gapminder data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ngp <- gapminder::gapminder\n```\n:::\n\n\n## 3.2.1 `group_by()` function\n\nSuppose you want to find the average life expectancy per continent. `group_by()` function comes in handy when we want to aggregate data by group:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp |> \n  group_by(continent) |> \n  summarise(le_continent = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  continent le_continent\n  <fct>            <dbl>\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n```\n:::\n:::\n\n\nWe can arrange the output from highest to lowest:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp |> \n  group_by(continent) |> \n  summarise(life_exp_continent = mean(lifeExp)) |> \n  arrange(desc(life_exp_continent))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  continent life_exp_continent\n  <fct>                  <dbl>\n1 Oceania                 74.3\n2 Europe                  71.9\n3 Americas                64.7\n4 Asia                    60.1\n5 Africa                  48.9\n```\n:::\n:::\n\n\n\nYou can play around with  `group_by()` and other `dplyr` functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp |> \n  filter(year == 2007) |> \n  group_by(continent) |> \n  summarise(life_exp_continent = mean(lifeExp), \n            median_life_exp = median(lifeExp),\n            sd_life_exp = sd(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n  continent life_exp_continent median_life_exp sd_life_exp\n  <fct>                  <dbl>           <dbl>       <dbl>\n1 Africa                  54.8            52.9       9.63 \n2 Americas                73.6            72.9       4.44 \n3 Asia                    70.7            72.4       7.96 \n4 Europe                  77.6            78.6       2.98 \n5 Oceania                 80.7            80.7       0.729\n```\n:::\n:::\n\n\n# Conclusion \n\nThere are two key takeaways from this week:\n\n- `dplyr` (and the rest of `tidyverse`) is magic\n\n- The pipe `|>` operator is awesome\n\nThe pipe operator allows us to connect different functions in a single code: \n\n![Credit: @fjnogales](images/pipe.gif)\nYou might also think of a pipe operator as a baking process:\n\n![Credit:@ArthurWelle](images/pipe_bake.gif)\n\nIn the next section, we introduce the fundamentals of data visualisation using `ggplot2` package (also included in the `tidyverse`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}