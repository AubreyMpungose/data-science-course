[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "R Can be downloaded from CRAN, The Comprehensive R Archive Network. Simply go to the CRAN wesbite\nDownload the latest version of R (currently R-4.2.1 ) depending on the operating system of your machine:\n\nWindows\nmacOS\nLinux"
  },
  {
    "objectID": "getting-started.html#installing-rstudio",
    "href": "getting-started.html#installing-rstudio",
    "title": "Getting Started",
    "section": "1.1 Installing RStudio",
    "text": "1.1 Installing RStudio\nRstudio is an Integrated Development Environment (IDE) that makes it easier working with R. This might be trickier for beginners who are not familiar with programming. Think of R as the engine that makes the car run. RStudio would be additional aesthetics that makes the car look better. You can use R without RStudio to analyse data, but you cannot use RStudio without R. You can download the latest version of RStudio here. Make sure to sure RStudio Desktop\n\n\n\n\n\n\nR console\n\n\n\n\n\n\n\nRStudio\n\n\n\n\n\nIn RStudio, you have 4 panes, the script, where you can write lines of code and save the script for future purposes. On the top-right you have the Environment pane, where we can view the list of objects we have created in R; objects can include tables, datasets, models, plots, etc. On bottom-right, we have a console, it is the typical console we found R. Lastly, the last pane have different components/tabs: files tzb, where we can view the list of files we are connected to or are using; for example, where you stored you dataset. It also has a plot tab, used for viewing plots/graphs."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Workshops for Data Science",
    "section": "",
    "text": "These workshops aim to introduce participants to the foundations of data science using R programming Language. As most of you are post-graduate students in geography, adding data science to your bag of skills will important going forward;it will help you in your own research and improving your advantage in labour market.\nIn this course, we will be using R for programming and data analysis. R, along with other languages such as Python and Julia, is flexible when working with data, especially large data. Majority of academics, researchers, and students who analyse quantitative data use programs such as SPSS, STATA and Excel, and I have also used them before. I discourage the use of these tools for following reasons. Firstly, they are expensive! Universities spend large sums of money to purchase these licences, which disadvantages students and academics in the developing world. On the other hand, R, Python and Julia are free and come with with ABSOLUTELY NO WARRANTY 😎 . Secondly, programming tools such as R, Python and Julia allow for Reproducible Science. Recently, there has been a call among global scientists to make their analyses and results as open as possible. This means sharing the code and all the outputs so that other researchers can examine your work.\nI choose to work with R, simply because it is an awesome tool and I f***n love it! While I also use Python, however, as a social science student, who did not have a computer science and programming background, R was easier for me to learn."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "R Workshops for Data Science",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand R and its functions\nConduct basic programming using R\nLearn to wrangle, clean and transform categorical data\nLearn to wrangle, clean and transform numerical data\nLearn the basics of data visualisation using ggplot2\nLearn how to conduct exploratory data analysis\nLearn to conduct basic statistical analysis (descriptive and inferential)\nLearn to communicate and tell stories using data"
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "R Workshops for Data Science",
    "section": "Materials",
    "text": "Materials\nThere are tons of materials available online; below I share compulsory and recommended materials we will beusing. There will be additional materials and slides for each section:\n\nWickham, H., & Grolemund, G. (2016). R for Data Science: import, tidy, transform, visualize, and model data. O’Reilly Media, Inc.\nHealy, K. (2018). Data visualization: a practical introduction. Princeton University Press.\nPeng, R. (2013) Exploratory Data Analysis with R"
  },
  {
    "objectID": "index.html#lets-get-started",
    "href": "index.html#lets-get-started",
    "title": "R Workshops for Data Science",
    "section": "Let’s Get Started",
    "text": "Let’s Get Started"
  },
  {
    "objectID": "my-profile.html",
    "href": "my-profile.html",
    "title": "About Me",
    "section": "",
    "text": "I am a geographer by training, currently completing my PhD, focusing on the geographies of youth. I work as a lecturer in the School of Education, University of KwaZulu Natal, Pietermaritzburg Campus. My research interests include urban and political geography, political economy, computational social science and quantitative social science. I use data science tools, computational methods and statistical modelling in my research. I enjoy analysing data in R and Python."
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Week\nTopic\nPresenter\nRead\n\n\n\n\n\n\n1\nIntroduction: Basics of R functions\nAubrey\n📖\n\n\n\n\n2\nData Structures and Types\nAubrey\n📖\n\n\n\n\n3\nData Wrangling\nAubrey\n📖\n\n\n\n\n4\nData Visualisation\nAubrey\n📖\n\n\n\n\n5\nExploratory Data Analysis, summary statistics\nAubrey\n📖\n\n\n\n\n6\nHypothesis Testing\nAubrey\n📖\n\n\n\n\n7\nRegression: Linear and Logistic\nAubrey\n📖\n\n\n\n\n8\nCommunicating and Reporting Data using RMarkdown\nAubrey\n📖\n\n\n\n\n8\nData Science Toolbox, where to from here?\nAubrey\n📖"
  },
  {
    "objectID": "weeks/week-1.html",
    "href": "weeks/week-1.html",
    "title": "Introduction to R Programming",
    "section": "",
    "text": "understand the basics of R programming\nUnderstand data types and objects\nunderstand base (built-in) R functions"
  },
  {
    "objectID": "weeks/week-1.html#reading",
    "href": "weeks/week-1.html#reading",
    "title": "Introduction to R Programming",
    "section": "Reading",
    "text": "Reading"
  },
  {
    "objectID": "weeks/week-1.html#basics-of-r",
    "href": "weeks/week-1.html#basics-of-r",
    "title": "Introduction to R Programming",
    "section": "Basics of R",
    "text": "Basics of R\nIn the getting started section, we showed the layout of RStudio. For this lesson, you will write all the code in the scripts/source and see the output in the console. To comment on the code, you will use the hashtag (#) to tell R not to execute the line as a code.\nR can be used as a calculator:\n4 + 7 \n[1] 11\n9 * 6 \n[1] 54\n\nArithmetic Operators\n\n\n\nDescription\nOperator\nExample\n\n\n\n\nAddition\n+\n1 + 3\n\n\nSubtract\n-\n90 - 5\n\n\nMultiplication\n*\n6 * 7\n\n\nExponentiation\n^\n3 ^ 6\n\n\nDivision\n/\n54 / 7\n\n\n\nType in and run the above examples in the script or console.\n\n\nAssignment operator\nNotice that we have been running previous codes without assigning them to objects. We use the assignment operator (<-) in R to assign whatever we have created into object; this can be a plot, a variable, a table, etc. Using above example, let us recreate our code but assigning them:\n\naddition <- 4 + 7 \n\nprint(addition)\n\n[1] 11\n\nmultiplication <- 9 * 6 \n\nprint(multiplication)\n\n[1] 54\n\n\nNotice in the above code, we have told R to create an object called ‘addition’ and every time we call print() function, the results will be printed in the console. Please remember the assignment operator (<-) as we will use it through this course. We can also assign objects using =:\n\naddition = 4 + 7\n\nprint(addition)\n\n[1] 11\n\n\nHowever, many R programmers and I use the <- operator for a serious reasons; so we will stick to it.\nAlso, you do not necessarily need to call the print() function in order to print results/output, you can just write the name of the object you have created, run it and it will be printed:\n\nage <- 32\n\nage\n\n[1] 32\n\n\nNotice that the object age, which has my age in 2022 was printed on the console.\nBasically, we have created variables (addition, multiplication, age). With these variables, we can perform basic analysis:\n\naubrey_age <- 32\n\ncharity_age <- 24\n\n# Find age difference\naubrey_age - charity_age\n\n[1] 8\n\n# sum of ages\n\ncharity_age + aubrey_age\n\n[1] 56\n\n\n\n\nData types in R\nThere 3 basic data types in R\n\ncharacter: strings, text, etc\nnumeric: numbers, can be integers or whole numbers\nlogical: TRUE/FALSE, also called Boolean\n\nAn example of a character:\n\nname <- \"Aubrey\"\n\ngender <- \"male\"\n\nNotice that a character need to be surrounded by (““) every time, otherwise R will return an error\n\nname <- Aubrey\n\nError in eval(expr, envir, enclos): object 'Aubrey' not found\n\ngender <- male\n\nError in eval(expr, envir, enclos): object 'male' not found\n\n\nAn example of a numerical:\n\nincome <- 1500\n \nincome # print income\n\n[1] 1500\n\nheight <- 1.9\n\nheight # print height\n\n[1] 1.9\n\n\nAn example of a logical data type:\n\nmale <- TRUE\n\nmale \n\n[1] TRUE\n\nfemale <- FALSE\n\nfemale \n\n[1] FALSE\n\n\nYou can ask R to tell you the type of the data structure by using class() function:\n\nclass(aubrey_age)\n\n[1] \"numeric\"\n\nclass(income)\n\n[1] \"numeric\"\n\nclass(name)\n\n[1] \"character\"\n\nclass(male)\n\n[1] \"logical\""
  },
  {
    "objectID": "weeks/week-1.html#base-r-functions",
    "href": "weeks/week-1.html#base-r-functions",
    "title": "Introduction to R Programming",
    "section": "Base R functions",
    "text": "Base R functions\nR has built-in functions that we can use to analyse and manipulate data. A function is always followed by (). We will use examples to illustrate various R functions.\n\nSummary statistics\nBasic summary statistics functions are mean, median, range, standard deviation, etc. We can get in R using the mean() function:\n\n# first create a vector of numbers\n\nage <- c(34, 18, 19, 58, 22)\n\nage\n\n[1] 34 18 19 58 22\n\nmean(age)\n\n[1] 30.2\n\n\nThe mean of a age variable we have created is 30.2.\nWe can use the median() function to get the median of our variable:\n\nmedian(age)\n\n[1] 22\n\n\nThe median age is 30.2\nAnd also the standard deviation using sd() function:\n\nsd(age)\n\n[1] 16.79881\n\n\nYou can get minimum and maximum values using min() and max() functions, respectively:\n\nmin(age)\n\n[1] 18\n\nmax(age)\n\n[1] 58\n\n\nYou can create a basic plot using a hist() function:\n\nhist(age)\n\n\n\n\nYou may want to arrange the values into ascending or descending order using the sort() function:\n\nsort(age) # sort into ascending order\n\n[1] 18 19 22 34 58\n\nsort(age, decreasing = T) # sort into descending order\n\n[1] 58 34 22 19 18\n\n\nIn this week, you have learnt basic data types, functions and operators. Next, we learn different type of data structures."
  },
  {
    "objectID": "weeks/week-2.html",
    "href": "weeks/week-2.html",
    "title": "2 Data Types in R",
    "section": "",
    "text": "While I aim to introduce data types: vectors, dataframes, lists, matrices, however our key focus is on dataframes"
  },
  {
    "objectID": "weeks/week-2.html#learning-objectives",
    "href": "weeks/week-2.html#learning-objectives",
    "title": "2 Data Types in R",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nTo understand data types: vectors, dataframes, lists, matrices\nTo do basic analysis"
  },
  {
    "objectID": "weeks/week-2.html#please-read",
    "href": "weeks/week-2.html#please-read",
    "title": "2 Data Types in R",
    "section": "Please Read",
    "text": "Please Read"
  },
  {
    "objectID": "weeks/week-2.html#vectors",
    "href": "weeks/week-2.html#vectors",
    "title": "2 Data Types in R",
    "section": "2.1 Vectors",
    "text": "2.1 Vectors\nRemember objects we created in the previous section? Those were all vectors. A vector is the basic data structure used to hold values of the same type. Similar to the previous section, a vector can be:\n\nnumeric\ncharacter\nlogical\n\nAlthough we are repeating stuff from previous section, but it worth it. Let us create a character vector from the names of the this class:\n\nnames <- c(\"thabiso\", \"nontando\", \"thandolwethu\", \"akhona\", \"perry\", \"balindile\", \"thembelani\", \"sabeliwe\",  \"phakamani\",    \"obianuju\", \"tshepang\", \"charity\", \"lungelo\", \"ntsikelelo\", \"akhona\", \"duduzile\")\n\nnames\n\n [1] \"thabiso\"      \"nontando\"     \"thandolwethu\" \"akhona\"       \"perry\"       \n [6] \"balindile\"    \"thembelani\"   \"sabeliwe\"     \"phakamani\"    \"obianuju\"    \n[11] \"tshepang\"     \"charity\"      \"lungelo\"      \"ntsikelelo\"   \"akhona\"      \n[16] \"duduzile\"    \n\n\nWe have a vector of names of this class, and assigned to an object names. Let us use basic functions to examine our names vector. We can get the type of vector by using class() function:\n\nclass(names)\n\n[1] \"character\"\n\n\nWe can examine the length by using length() function:\n\nlength(names)\n\n[1] 16\n\n\nWe have 16 items in the names vector\nFor numerical vector, we will use imaginary ages of this class:\n\nclass_age <- c(19, 59, 20, 28, 59, 44, 29, 13, 09, 23, 16)\n\nclass_age\n\n [1] 19 59 20 28 59 44 29 13  9 23 16\n\n\nwe have numerical vector that we named class_age. Let us do basic analyses of this vector. We can get the mean by using mean() functions:\n\nmean(class_age)\n\n[1] 29\n\n\nWe can get the median and standard deviation of class_age vector using median() and sd() fucntions, respectively:\n\nmedian(class_age)\n\n[1] 23\n\nsd(class_age)\n\n[1] 17.51571\n\n\nYou can get an element of vector by using [] function. Let us get the first element in names vector:\n\nnames[1]\n\n[1] \"thabiso\"\n\n\nKey lesson: a vector holds items of a similar type; as we have seen in the names and class_age vectors."
  },
  {
    "objectID": "weeks/week-2.html#dataframes",
    "href": "weeks/week-2.html#dataframes",
    "title": "2 Data Types in R",
    "section": "2.2 Dataframes",
    "text": "2.2 Dataframes\nDataframes will be the key focus throughout the course, so I will just briefly explain what is a dataframe. A dataframe is tabular data format, consisting of columns and rows. Let us use an example by creating a dataframe in R:\n\n# Create a character vetor\nnames <- c(\"thabiso\", \"nontando\", \"thandolwethu\", \"akhona\", \"perry\", \"balindile\", \"thembelani\", \"sabeliwe\",  \"phakamani\",    \"obianuju\", \"tshepang\", \"charity\", \"lungelo\", \"ntsikelelo\", \"akhona\", \"duduzile\")\n\nset.seed(14) #I do this so that we can get same results every time we generate numbers or simulate\nage <- sample(18:32, 16, replace = T) # Here i am generating random ages, from ages 16 to 32, with a sample of 16 people, to match our names vector\n\nnames\n\n [1] \"thabiso\"      \"nontando\"     \"thandolwethu\" \"akhona\"       \"perry\"       \n [6] \"balindile\"    \"thembelani\"   \"sabeliwe\"     \"phakamani\"    \"obianuju\"    \n[11] \"tshepang\"     \"charity\"      \"lungelo\"      \"ntsikelelo\"   \"akhona\"      \n[16] \"duduzile\"    \n\nage\n\n [1] 26 26 28 21 28 31 31 21 27 32 18 26 20 29 22 20\n\n\nTo create a dataframe, we will use a data.frame() function:\n\ndata_frame <- data.frame(names, age) #combine two vectors to create a dataframe\n\ndata_frame\n\n          names age\n1       thabiso  26\n2      nontando  26\n3  thandolwethu  28\n4        akhona  21\n5         perry  28\n6     balindile  31\n7    thembelani  31\n8      sabeliwe  21\n9     phakamani  27\n10     obianuju  32\n11     tshepang  18\n12      charity  26\n13      lungelo  20\n14   ntsikelelo  29\n15       akhona  22\n16     duduzile  20\n\n\nBingo! We have a dataframe with names and age columns, and individual rows. As I said earlier, This course is all about dataframes (tabular data)."
  },
  {
    "objectID": "weeks/week-2.html#other-data-types-matrices-and-lists",
    "href": "weeks/week-2.html#other-data-types-matrices-and-lists",
    "title": "2 Data Types in R",
    "section": "2.3 Other data types: matrices and lists",
    "text": "2.3 Other data types: matrices and lists\nYou will learn more about matrix objects when you advance in your data science career.\nlists are another data structure that are used to hold objects of different type. For example, they can hold both vector and dataframe:\n\nnames <- c(\"thabiso\", \"nontando\", \"thandolwethu\", \"akhona\", \"perry\", \"balindile\", \"thembelani\", \"sabeliwe\",  \"phakamani\",    \"obianuju\", \"tshepang\", \"charity\", \"lungelo\", \"ntsikelelo\", \"akhona\", \"duduzile\")\n\nset.seed(14) #I do this so that we can get same results every time we generate numbers or simulate\nage <- sample(18:32, 16, replace = T)\n\ndata_frame <- data.frame(names, age)\n\nheight <- runif(min = 1, max = 1.9, n =16)\n\nWe have 2 objects: data_frame (dataframe) and height (vector). From these objects, we can create a lists:\n\nfirst_list <- list(data_frame, height)\n\nfirst_list\n\n[[1]]\n          names age\n1       thabiso  26\n2      nontando  26\n3  thandolwethu  28\n4        akhona  21\n5         perry  28\n6     balindile  31\n7    thembelani  31\n8      sabeliwe  21\n9     phakamani  27\n10     obianuju  32\n11     tshepang  18\n12      charity  26\n13      lungelo  20\n14   ntsikelelo  29\n15       akhona  22\n16     duduzile  20\n\n[[2]]\n [1] 1.766411 1.535822 1.315833 1.377657 1.555922 1.621243 1.674928 1.557059\n [9] 1.346348 1.471001 1.618520 1.070648 1.730195 1.123595 1.871876 1.588802\n\n\nDid you see that Jimmy? We actually printed the list.\nLet us go to dataframes, which is the core of this course"
  },
  {
    "objectID": "weeks/week-3.html",
    "href": "weeks/week-3.html",
    "title": "3 Wrangling Dataframes in R",
    "section": "",
    "text": "Understand dataframes\nManipulate, transform and analyse dataframes"
  },
  {
    "objectID": "weeks/week-3.html#introduction",
    "href": "weeks/week-3.html#introduction",
    "title": "3 Wrangling Dataframes in R",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nDataframes, as we saw the previous section, a dataframe is a tabular data format, with columns and rows. Columns are variable names and rows are individual observations. Let us recreate the previous dataframe of names and ages of this class:\n\n# Firstly, create a character vector with names\nnames <- c(\"thabiso\", \"nontando\", \"thandolwethu\", \"akhona\", \"perry\", \"balindile\", \"thembelani\", \"sabeliwe\",  \"phakamani\",    \"obianuju\", \"tshepang\", \"charity\", \"lungelo\", \"ntsikelelo\", \"akhona\", \"duduzile\")\n\nset.seed(14) #I do this so that we can get same results every time we generate numbers or simulate\n\n# Create a numeric vector of ages\nage <- sample(18:32, 16, replace = T)\n\n# Create a dataframe\ndata_frame <- data.frame(names, age) \n\n# print the dataframe\ndata_frame \n\n          names age\n1       thabiso  26\n2      nontando  26\n3  thandolwethu  28\n4        akhona  21\n5         perry  28\n6     balindile  31\n7    thembelani  31\n8      sabeliwe  21\n9     phakamani  27\n10     obianuju  32\n11     tshepang  18\n12      charity  26\n13      lungelo  20\n14   ntsikelelo  29\n15       akhona  22\n16     duduzile  20\n\n\nA dataframe is basically made of vectors. In our data_frame, we have character (names) and numeric (age) vectors that make our dataframe. We can extract these elements using the $ sign:\n\ndata_frame$names\n\n [1] \"thabiso\"      \"nontando\"     \"thandolwethu\" \"akhona\"       \"perry\"       \n [6] \"balindile\"    \"thembelani\"   \"sabeliwe\"     \"phakamani\"    \"obianuju\"    \n[11] \"tshepang\"     \"charity\"      \"lungelo\"      \"ntsikelelo\"   \"akhona\"      \n[16] \"duduzile\"    \n\ndata_frame$age\n\n [1] 26 26 28 21 28 31 31 21 27 32 18 26 20 29 22 20\n\n\nWe can do a range of analysis with a dataframe. But firstly, we need to use right functions for this task."
  },
  {
    "objectID": "weeks/week-3.html#base-r-vs-tidyverse",
    "href": "weeks/week-3.html#base-r-vs-tidyverse",
    "title": "3 Wrangling Dataframes in R",
    "section": "3.2 Base R vs Tidyverse",
    "text": "3.2 Base R vs Tidyverse\nUntil now, we have used functions within Base R, which are already installed in R. But in many cases, we want to use external packages to do any task we want. For example, if we want to do spatial and GIS analysis, we can install the sf package; we can use tidymodels to conduct machine learning models and so on. There are over 2000 R packages, contributed by different individuals around the world, and they are stored and curated in the CRAN website.\nOne of the most popular packages in R is the tidyverse meta-package, which include a collection of packages for working with data; most popular packages in the tidyverse are:\n\ndplyr: for data cleaning, wrangling and transformation\nggplot2: for data visualisation\ntidyr: for tidying up data\n\nThere are other packages in the tidyverse. The philosophy of tidyverse is tidy data:\n\n\nEach variable is a column; each column is a variable.\nEach observation is row; each row is an observation.\nEach value is a cell; each cell is a single value. [@r_4_ds]\n\n\nTidy data is a principle we are going to stick on through this course:\n\n\n\nTidy data @wickham_tidyverse_2019\n\n\nSo all in all, tidyverse make it easier to work with dataframes and most people prefer it than base R functions. We will use an example at the end to understand the differences between Base R and tydiverse. You will need to install the package first. In R you install a package by calling install.package() function:\n\ninstall.packages(\"tidyverse\")\n\nAfter installing the package, you need to load it into the current R session using library() function:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "weeks/week-3.html#using-dplyr",
    "href": "weeks/week-3.html#using-dplyr",
    "title": "3 Wrangling Dataframes in R",
    "section": "3.3 Using dplyr",
    "text": "3.3 Using dplyr\nIn this section dplyr packages, which is included in the tidyverse collection of packages. dplyr has 5 verbs/functions:\n\nselect()\nfilter()\narrange()\nsummarise()\nmutate()\n\n\n3.3.1 Load the dataset\nAll along, we have been working with fictional data. Let us use the gapminder dataset, which can be installed as:\n\ninstall.packages(\"gapminder\")\n\nAfter installing the gapminder data, you will have to load it using library function:\n\nlibrary(gapminder)\n\nThan assign it to the object, gapminder, using the <- operator:\n\ngapminder <- gapminder\n\nNow you have an object, which is a dataframe, called gapminder, you can see it in the Environment pane in RStudio. It shows that it has ncol(gapminder) columns/variables and nrow(gapminder) observations/rows\n\n\n\ngapminder dataframe in Environment pane\n\n\nYou can use the str() fucntion to get the structure of the dataframe:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nWe have 6 variables: - “country”\n\n“continent”\n“year”\n“lifeExp”: life expectancy of a country\n“pop”: population\n“gdpPercap”: GDP per capita\n\nYou can get a sample of the first observations/rows using head() function:\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\n\n3.4.2 select() function\nWe may be interested in some of the columns in the gampminder dataframe, let say, for example, “country” and “pop” variables and discard others; we use the select() function:\n\nlibrary(dplyr)\nselect(gapminder, \"country\", \"pop\")\n\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n\n\nR return only the country and population variables. The best way to work with R is using a pipe (|>) operator. A pipe operator connect various tasks, for example:\n\ngapminder |>\n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n\n\nYou will see the importance of the pipe operator later when our analysis get complicated. Throught the course, we will use the pipe operator. Also, you will in many textbooks and online resources uses the %>% operator instead. That is because initially, a pipe operator was an external function within the mgttr package, so it was not an built-in R function. In recent years, the base R |> pipe operator has been developed and we will stick to it. But they all do the same thing, so it your preference:\n\ngapminder %>% \n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n\n\nAlso, notice that we selected “country’ and”pop” columns but did not save them and assigned to an object. To store the results into an object, we have to use assignment operator (<-):\n\ngapminder_selected <- gapminder |>\n  select(country, pop)\n\ngapminder_selected # print\n\n# A tibble: 1,704 × 2\n   country          pop\n   <fct>          <int>\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# … with 1,694 more rows\n\n\nNow we have saved results as gapminder_selected, and we can do other analysis with this object because we have saved it. So, in a nutshell, when you run a code without assigning results into an object, using the <- operator, results will not be saved but will be printed.\n\n\n3.4.3 filter() function\nYou may be interested in observations that meet certain conditions. We use filter() function to return the list that meet our conditions. Let us “continent” variable in gapminder dataframe. Get a basic table first:\n\ntable(gapminder$continent)\n\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nThere are five continents. Let us filter only observations from the Africa continent:\n\nafrica_gapminder <- gapminder |> \n  filter(continent == \"Africa\")\n\nafrica_gapminder  # print \n\n# A tibble: 624 × 6\n   country continent  year lifeExp      pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# … with 614 more rows\n\n\nafrica_gapminder object is a dataframe we have just created, with only countries from the African continent.\nLet us filter a numeric vector; for example, we may want to filter countries with population of above 50 million and assign results to an object named high_pop:\n\nhigh_pop <- gapminder |> \n  filter(pop > 50000000)\n\nhigh_pop\n\n# A tibble: 190 × 6\n   country    continent  year lifeExp       pop gdpPercap\n   <fct>      <fct>     <int>   <dbl>     <int>     <dbl>\n 1 Bangladesh Asia       1957    39.3  51365468      662.\n 2 Bangladesh Asia       1962    41.2  56839289      686.\n 3 Bangladesh Asia       1967    43.5  62821884      721.\n 4 Bangladesh Asia       1972    45.3  70759295      630.\n 5 Bangladesh Asia       1977    46.9  80428306      660.\n 6 Bangladesh Asia       1982    50.0  93074406      677.\n 7 Bangladesh Asia       1987    52.8 103764241      752.\n 8 Bangladesh Asia       1992    56.0 113704579      838.\n 9 Bangladesh Asia       1997    59.4 123315288      973.\n10 Bangladesh Asia       2002    62.0 135656790     1136.\n# … with 180 more rows\n\n\nYou can also combine 2 conditions. Let us say we want:\n\ncountries in Africa\nyear 2007\nthat have a population of more than 50 million\n\nWe can combine these arguments and assign results into an object we name africa_2007:\n\nafrica_2007 <- gapminder |> \n  filter(continent == \"Africa\", year == 2007, pop > 50000000)\n\n# print the result\nafrica_2007\n\n# A tibble: 4 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n1 Congo, Dem. Rep. Africa     2007    46.5  64606759      278.\n2 Egypt            Africa     2007    71.3  80264543     5581.\n3 Ethiopia         Africa     2007    52.9  76511887      691.\n4 Nigeria          Africa     2007    46.9 135031164     2014.\n\n\n\n\n3.4.4 arrange() function\narrange() function sort values in ascending or descending order; the default is ascending:\n\ngapminder |> \n  arrange(lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# … with 1,694 more rows\n\n\nHere we have sorted lifeExp column in ascending order; to arrange in descending order, you have to use desc() function within arrange():\n\ngapminder |> \n  arrange(desc(lifeExp))\n\n# A tibble: 1,704 × 6\n   country          continent  year lifeExp       pop gdpPercap\n   <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n 1 Japan            Asia       2007    82.6 127467972    31656.\n 2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n 3 Japan            Asia       2002    82   127065841    28605.\n 4 Iceland          Europe     2007    81.8    301931    36181.\n 5 Switzerland      Europe     2007    81.7   7554661    37506.\n 6 Hong Kong, China Asia       2002    81.5   6762476    30209.\n 7 Australia        Oceania    2007    81.2  20434176    34435.\n 8 Spain            Europe     2007    80.9  40448191    28821.\n 9 Sweden           Europe     2007    80.9   9031088    33860.\n10 Israel           Asia       2007    80.7   6426679    25523.\n# … with 1,694 more rows\n\n\n\n\n3.4.5 summarise()\nThe summarise() function is for calculating statistics such as mean, median, sum, min, max, etc. let us use examples. We may want the average GDP per capita in in 2007:\n\n# first filter the year 2007 and save the results as gapminder_2007\n\ngapminder_2007 <- gapminder |> \n  filter(year == 2007)\n\n# then use use the summarise() function\n\ngapminder_2007 |> \n  summarise(avg_gdp = mean(gdpPercap))\n\n# A tibble: 1 × 1\n  avg_gdp\n    <dbl>\n1  11680.\n\n\nNotice that we have called summarise() from the dplyr package, then created a column avg_gdp that use the built-in (base R) mean() function and put the gdpPercap column within it to get the average GDP per capita in 2007. This is similar for other stats: median:\n\ngapminder_2007 |> \n  summarise(median_life_exp = median(lifeExp))\n\n# A tibble: 1 × 1\n  median_life_exp\n            <dbl>\n1            71.9\n\n\nWe can get minimum (using min()), maximum (max()), sum (sum()) etc. get the lowest population:\n\ngapminder_2007 |> \n  summarise(lowest_pop = min(pop))\n\n# A tibble: 1 × 1\n  lowest_pop\n       <int>\n1     199579\n\n\nGet the highest population:\n\ngapminder_2007 |> \n  summarise(highest_pop = max(pop))\n\n# A tibble: 1 × 1\n  highest_pop\n        <int>\n1  1318683096\n\n\nGet the total world population:\n\ngapminder_2007 |> \n  summarise(total_pop = sum(pop))\n\n# A tibble: 1 × 1\n   total_pop\n       <dbl>\n1 6251013179\n\n\n\n\n3.4.6 mutate()\nSuppose we want to create a new column in the dataframe, using existing columns. The mutate() function is useful here. Consider the gdpPercap column/variable; from your basic school economics or general knowledge, you know that a GDP is total value of goods and services produced within a country, and is used to measure the economy. We also know that the GDP per capita is calculated by dividing GDP by the population, so it is GDP per person. In gapminder dataframe, there are gdpPercap and pop, which we can use to calculate GDP of a country; we will use mutate() for this:\n\ngapminder_2007 <- gapminder_2007 |> \n  mutate(gdp = gdpPercap * pop)\n\n# print the results\n\ngapminder_2007\n\n# A tibble: 142 × 7\n   country     continent  year lifeExp       pop gdpPercap           gdp\n   <fct>       <fct>     <int>   <dbl>     <int>     <dbl>         <dbl>\n 1 Afghanistan Asia       2007    43.8  31889923      975.  31079291949.\n 2 Albania     Europe     2007    76.4   3600523     5937.  21376411360.\n 3 Algeria     Africa     2007    72.3  33333216     6223. 207444851958.\n 4 Angola      Africa     2007    42.7  12420476     4797.  59583895818.\n 5 Argentina   Americas   2007    75.3  40301927    12779. 515033625357.\n 6 Australia   Oceania    2007    81.2  20434176    34435. 703658358894.\n 7 Austria     Europe     2007    79.8   8199783    36126. 296229400691.\n 8 Bahrain     Asia       2007    75.6    708573    29796.  21112675360.\n 9 Bangladesh  Asia       2007    64.1 150448339     1391. 209311822134.\n10 Belgium     Europe     2007    79.4  10392226    33693. 350141166520.\n# … with 132 more rows"
  },
  {
    "objectID": "weeks/week-3.html#conclusion",
    "href": "weeks/week-3.html#conclusion",
    "title": "3 Wrangling Dataframes in R",
    "section": "3.5 Conclusion",
    "text": "3.5 Conclusion\nWe have explored, the basic of data manipulation using dplyr package. In the next chapter, things will get more serious."
  }
]